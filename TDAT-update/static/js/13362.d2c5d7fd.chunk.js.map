{"version":3,"file":"static/js/13362.d2c5d7fd.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/esm/src/components/functional/Validation.tsx","../node_modules/@esri/calcite-components/dist/esm/src/utils/component.ts","../node_modules/@esri/calcite-components/dist/esm/src/utils/form.tsx","../node_modules/@esri/calcite-components/dist/esm/src/components/input/common/input.ts","../node_modules/@esri/calcite-components/dist/esm/src/utils/interactive.tsx","../node_modules/@esri/calcite-components/dist/esm/src/utils/label.ts","../node_modules/@esri/calcite-components/dist/esm/src/utils/t9n.ts"],"sourcesContent":["import { FunctionalComponent, h, VNode } from \"@stencil/core\";\nimport { JSXBase } from \"@stencil/core/internal\";\nimport { Scale, Status } from \"../interfaces\";\nimport { IconNameOrString } from \"../icon/interfaces\";\n\ninterface ValidationProps extends JSXBase.HTMLAttributes {\n  scale: Scale;\n  status: Status;\n  icon?: IconNameOrString | boolean;\n  id?: string;\n  message: string;\n}\n\nexport const CSS = {\n  validationContainer: \"validation-container\",\n};\n\nexport const Validation: FunctionalComponent<ValidationProps> = ({\n  scale,\n  status,\n  id,\n  icon,\n  message,\n}): VNode => (\n  <div class={CSS.validationContainer}>\n    <calcite-input-message aria-live=\"polite\" icon={icon} id={id} scale={scale} status={status}>\n      {message}\n    </calcite-input-message>\n  </div>\n);\n","import { HTMLStencilElement } from \"@stencil/core/internal\";\nimport { Scale } from \"../components/interfaces\";\n\nexport function getIconScale(componentScale: Scale): Extract<Scale, \"s\" | \"m\"> {\n  return componentScale === \"l\" ? \"m\" : \"s\";\n}\n\n/**\n * This util helps us wait for a component to be ready for both lazy-loading (`dist` output) and non-lazy-loading (`components` output) components.\n *\n * Based on https://github.com/ionic-team/ionic-framework/blob/1a8bd6d/core/src/utils/helpers.ts#L60C1-L79C3\n *\n * @param el - the host element to wait for\n */\nexport async function componentOnReady(el: HTMLElement): Promise<void> {\n  await (isStencilEl(el)\n    ? el.componentOnReady()\n    : new Promise<void>((resolve) => requestAnimationFrame(() => resolve())));\n}\n\nfunction isStencilEl(el: HTMLElement): el is HTMLStencilElement {\n  return typeof (el as HTMLStencilElement).componentOnReady === \"function\";\n}\n","import { FunctionalComponent, h, VNode } from \"@stencil/core\";\nimport { Writable } from \"type-fest\";\nimport { Status } from \"../components/interfaces\";\nimport type { IconNameOrString } from \"../components/icon/interfaces\";\nimport { closestElementCrossShadowBoundary, queryElementRoots } from \"./dom\";\n\n/**\n * Any form <Component> with a `calcite<Component>Input` event needs to be included in this array.\n */\nexport const componentsWithInputEvent = [\n  \"calcite-input\",\n  \"calcite-input-number\",\n  \"calcite-input-text\",\n  \"calcite-text-area\",\n];\n\n/**\n * Get the event name to listen for that, when emitted, will clear the\n * validation message that displays after form submission. Only validation\n * messages that are set by the browser will be cleared. If a user sets\n * validationMessage to a custom value, they are responsible for clearing it.\n *\n * Exported for testing purposes.\n *\n * @param componentTag the tag of the component, e.g. \"calcite-input\"\n * @returns the event name\n */\nexport function getClearValidationEventName(componentTag: string): string {\n  const componentTagCamelCase = componentTag\n    .split(\"-\")\n    .map((part: string, index: number) =>\n      index === 0 ? part : `${part[0].toUpperCase()}${part.slice(1)}`,\n    )\n    .join(\"\");\n\n  const clearValidationEvent = `${componentTagCamelCase}${\n    componentsWithInputEvent.includes(componentTag) ? \"Input\" : \"Change\"\n  }`;\n\n  return clearValidationEvent;\n}\n\nexport type MutableValidityState = Writable<ValidityState>;\n\n/**\n * Exported for testing purposes.\n */\nexport const hiddenFormInputSlotName = \"hidden-form-input\";\n\n/**\n * Defines interface for form owning components.\n *\n * Allows calling submit/reset methods on the form.\n */\nexport interface FormOwner {\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n\n  /**\n   * The ID of the form to associate with the component.\n   *\n   * When not set, the component will be associated with its ancestor form element, if any.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  form: string;\n\n  /**\n   * The form this component is associated with.\n   *\n   * @internal\n   */\n  formEl: HTMLFormElement;\n}\n\n/**\n * Defines interface for form-associated components.\n *\n * Along with the interface, use the matching form utils to help set up the component behavior.\n */\nexport interface FormComponent<T = any> extends FormOwner {\n  /**\n   * When true, this component's value will not be submitted in the form.\n   */\n  disabled: boolean;\n\n  /**\n   * When true, form submit requests will enforce field requirement.\n   *\n   * @todo remove optional in follow-up PR\n   */\n  required?: boolean;\n\n  /**\n   * The name used to submit the value to the associated form.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  name: string;\n\n  /**\n   * This form component's value.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  value: T;\n\n  /**\n   * The initial value for this form component.\n   *\n   * When the form is reset, the value will be set to this property.\n   */\n  defaultValue: T;\n\n  /** The validation icon to display. */\n  validationIcon?: string | boolean;\n\n  /** The validation message to display. */\n  validationMessage?: string;\n\n  /** The validity state of the form component. */\n  validity?: MutableValidityState;\n\n  /**\n   * Hook for components to provide custom form reset behavior.\n   */\n  onFormReset?: () => void;\n\n  /**\n   * Hook for components to sync _extra_ props on the hidden input form element used for form-submitting.\n   *\n   * Note: The following props are set by default: disabled, hidden, name, required, value.\n   */\n  syncHiddenFormInput?: (input: HTMLInputElement) => void;\n}\n\n/**\n * Defines interface for checkable form-associated components.\n *\n * Along with the interface, use the matching form utils to help set up the component behavior.\n */\nexport interface CheckableFormComponent<T = any> extends FormComponent<T> {\n  /**\n   * For boolean-valued components, this property defines whether the associated value is submitted to the form or not.\n   */\n  checked: boolean;\n\n  /**\n   * The initial checked value for this form component.\n   *\n   * When the form is reset, the checked property will be set to this value.\n   */\n  defaultChecked: boolean;\n}\n\nfunction isCheckable(component: FormComponent): component is CheckableFormComponent {\n  return \"checked\" in component;\n}\n\nconst onFormResetMap = new WeakMap<HTMLElement, FormComponent[\"onFormReset\"]>();\nconst formComponentSet = new WeakSet<HTMLElement>();\n\n/**\n * This helps determine if our form component is part of a composite form-associated component.\n *\n * @param form\n * @param formComponentEl\n */\nfunction hasRegisteredFormComponentParent(\n  form: HTMLFormElement,\n  formComponentEl: HTMLElement,\n): boolean {\n  // if we have a parent component using the form ID attribute, we assume it is form-associated\n  const hasParentComponentWithFormIdSet = closestElementCrossShadowBoundary(\n    formComponentEl.parentElement,\n    \"[form]\",\n  );\n\n  if (hasParentComponentWithFormIdSet) {\n    return true;\n  }\n\n  // we use events as a way to test for nested form-associated components across shadow bounds\n  const formComponentRegisterEventName = \"calciteInternalFormComponentRegister\";\n\n  let hasRegisteredFormComponentParent = false;\n\n  form.addEventListener(\n    formComponentRegisterEventName,\n    (event) => {\n      hasRegisteredFormComponentParent = event\n        .composedPath()\n        .some((element) => formComponentSet.has(element as HTMLElement));\n      event.stopPropagation();\n    },\n    { once: true },\n  );\n\n  formComponentEl.dispatchEvent(\n    new CustomEvent(formComponentRegisterEventName, {\n      bubbles: true,\n      composed: true,\n    }),\n  );\n\n  return hasRegisteredFormComponentParent;\n}\n\n// exported for test purposes only\nexport interface ValidationProps {\n  status: Status;\n  message: string;\n  icon: IconNameOrString | boolean | \"\";\n}\n\nfunction displayValidationMessage(\n  component: HTMLCalciteInputElement | FormComponent,\n  { status, message, icon }: ValidationProps,\n): void {\n  if (\"status\" in component) {\n    component.status = status;\n  }\n\n  if (\"validationIcon\" in component && typeof component.validationIcon !== \"string\") {\n    component.validationIcon = icon;\n  }\n\n  if (\"validationMessage\" in component && !component.validationMessage) {\n    component.validationMessage = message;\n  }\n}\n\nfunction getValidationComponent(\n  el: HTMLCalciteInputElement,\n  // TODO: create an HTMLCalciteFormAssociatedElement base type\n): HTMLCalciteInputElement | HTMLCalciteRadioButtonGroupElement {\n  // radio-button is formAssociated, but the validation props are on the parent group\n  if (el.nodeName === \"CALCITE-RADIO-BUTTON\") {\n    return closestElementCrossShadowBoundary(el, \"calcite-radio-button-group\");\n  }\n  return el;\n}\n\nconst invalidEvent = new CustomEvent(\"calciteInvalid\", { bubbles: true, composed: true });\n\nfunction invalidHandler(event: Event) {\n  // target is the hidden input, which is slotted in the actual form component\n  const hiddenInput = event?.target as HTMLInputElement;\n  const hiddenInputMessage = hiddenInput?.validationMessage;\n\n  // not necessarily a calcite-input, but we don't have an HTMLCalciteFormAssociatedElement type\n  const formComponent = getValidationComponent(\n    hiddenInput?.parentElement as HTMLCalciteInputElement,\n  ) as HTMLCalciteInputElement;\n\n  if (!formComponent) {\n    return;\n  }\n\n  const componentTag = formComponent?.nodeName?.toLowerCase();\n  const componentTagParts = componentTag?.split(\"-\");\n\n  if (componentTagParts.length < 2 || componentTagParts[0] !== \"calcite\") {\n    return;\n  }\n\n  // prevent the browser from showing the native validation popover\n  event?.preventDefault();\n\n  if (\"validity\" in formComponent) {\n    formComponent.validity = hiddenInput?.validity;\n  }\n\n  // dispatch a \"calciteInvalid\" so users can set custom validation messages\n  formComponent.dispatchEvent(invalidEvent);\n\n  displayValidationMessage(formComponent, {\n    message: hiddenInputMessage,\n    icon: true,\n    status: \"invalid\",\n  });\n\n  const clearValidationEvent = getClearValidationEventName(componentTag);\n  formComponent.addEventListener(\n    clearValidationEvent,\n    () => {\n      if (\"status\" in formComponent) {\n        formComponent.status = \"idle\";\n      }\n\n      if (\"validationIcon\" in formComponent && !formComponent.validationIcon) {\n        formComponent.validationIcon = false;\n      }\n\n      if (\n        \"validationMessage\" in formComponent &&\n        formComponent.validationMessage === hiddenInputMessage\n      ) {\n        formComponent.validationMessage = \"\";\n      }\n\n      if (\"validity\" in formComponent) {\n        formComponent.validity = hiddenInput?.validity;\n      }\n    },\n    { once: true },\n  );\n}\n\n/**\n * Helper to submit a form.\n *\n * @param component\n * @returns true if its associated form was submitted, false otherwise.\n */\nexport function submitForm(component: FormOwner): boolean {\n  const { formEl } = component;\n\n  if (!formEl) {\n    return false;\n  }\n\n  formEl.addEventListener(\"invalid\", invalidHandler, true);\n  formEl.requestSubmit();\n  formEl.removeEventListener(\"invalid\", invalidHandler, true);\n\n  requestAnimationFrame(() => {\n    const invalidEls = formEl.querySelectorAll<HTMLCalciteInputElement>(\"[status=invalid]\");\n\n    // focus the first invalid element that has a validation message\n    for (const el of invalidEls) {\n      if (el?.validationMessage) {\n        el?.setFocus();\n        break;\n      }\n    }\n  });\n\n  return true;\n}\n\n/**\n * Helper to reset a form.\n *\n * @param component\n */\nexport function resetForm(component: FormOwner): void {\n  component.formEl?.reset();\n}\n\n/**\n * Helper to set up form interactions on connectedCallback.\n *\n * @param component\n */\nexport function connectForm<T>(component: FormComponent<T>): void {\n  const { el, value } = component;\n  const associatedForm = findAssociatedForm(component);\n\n  if (!associatedForm || hasRegisteredFormComponentParent(associatedForm, el)) {\n    return;\n  }\n\n  component.formEl = associatedForm;\n  component.defaultValue = value;\n\n  if (isCheckable(component)) {\n    component.defaultChecked = component.checked;\n  }\n\n  const boundOnFormReset = (component.onFormReset || onFormReset).bind(component);\n  associatedForm.addEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.set(component.el, boundOnFormReset);\n  formComponentSet.add(el);\n}\n\n/**\n * Utility method to find a form-component's associated form element.\n *\n * @param component\n */\nexport function findAssociatedForm(component: FormOwner): HTMLFormElement | null {\n  const { el, form } = component;\n\n  return form\n    ? queryElementRoots<HTMLFormElement>(el, { id: form })\n    : closestElementCrossShadowBoundary(el, \"form\");\n}\n\nfunction onFormReset<T>(this: FormComponent<T>): void {\n  if (\"status\" in this) {\n    this.status = \"idle\";\n  }\n\n  if (\"validationIcon\" in this) {\n    this.validationIcon = false;\n  }\n\n  if (\"validationMessage\" in this) {\n    this.validationMessage = \"\";\n  }\n\n  if (isCheckable(this)) {\n    this.checked = this.defaultChecked;\n    return;\n  }\n\n  this.value = this.defaultValue;\n}\n\n/**\n * Helper to tear down form interactions on disconnectedCallback.\n *\n * @param component\n */\nexport function disconnectForm<T>(component: FormComponent<T>): void {\n  const { el, formEl } = component;\n\n  if (!formEl) {\n    return;\n  }\n\n  const boundOnFormReset = onFormResetMap.get(el);\n  formEl.removeEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.delete(el);\n  component.formEl = null;\n  formComponentSet.delete(el);\n}\n\n/**\n * Helper for setting the default value on initialization after connectedCallback.\n *\n * Note that this is only needed if the default value cannot be determined on connectedCallback.\n *\n * @param component\n * @param value\n */\nexport function afterConnectDefaultValueSet<T>(component: FormComponent<T>, value: any): void {\n  component.defaultValue = value;\n}\n\nexport const internalHiddenInputInputEvent = \"calciteInternalHiddenInputInput\";\n\nconst hiddenInputInputHandler = (event: Event) => {\n  event.target.dispatchEvent(new CustomEvent(internalHiddenInputInputEvent, { bubbles: true }));\n};\n\nconst removeHiddenInputChangeEventListener = (input: HTMLInputElement) =>\n  input.removeEventListener(\"input\", hiddenInputInputHandler);\n\n/**\n * Helper for maintaining a form-associated's hidden input in sync with the component.\n *\n * Based on Ionic's approach: https://github.com/ionic-team/ionic-framework/blob/e4bf052794af9aac07f887013b9250d2a045eba3/core/src/utils/helpers.ts#L198\n *\n * @param component\n */\nfunction syncHiddenFormInput(component: FormComponent): void {\n  const { el, formEl, name, value } = component;\n  const { ownerDocument } = el;\n\n  const inputs = el.querySelectorAll<HTMLInputElement>(`input[slot=\"${hiddenFormInputSlotName}\"]`);\n\n  if (!formEl || !name) {\n    inputs.forEach((input) => {\n      removeHiddenInputChangeEventListener(input);\n      input.remove();\n    });\n    return;\n  }\n\n  const values = Array.isArray(value) ? value : [value];\n  const extra: any[] = [];\n  const seen = new Set<any>();\n\n  inputs.forEach((input) => {\n    const valueMatch = values.find(\n      (val) =>\n        /* intentional non-strict equality check */\n        val == input.value,\n    );\n\n    if (valueMatch != null) {\n      seen.add(valueMatch);\n      defaultSyncHiddenFormInput(component, input, valueMatch);\n    } else {\n      extra.push(input);\n    }\n  });\n\n  let docFrag: DocumentFragment;\n\n  values.forEach((value) => {\n    if (seen.has(value)) {\n      return;\n    }\n\n    let input = extra.pop();\n\n    if (!input) {\n      input = ownerDocument.createElement(\"input\");\n      input.slot = hiddenFormInputSlotName;\n    }\n\n    if (!docFrag) {\n      docFrag = ownerDocument.createDocumentFragment();\n    }\n\n    docFrag.append(input);\n\n    // emits when hidden input is autofilled\n    input.addEventListener(\"input\", hiddenInputInputHandler);\n\n    defaultSyncHiddenFormInput(component, input, value);\n  });\n\n  if (docFrag) {\n    el.append(docFrag);\n  }\n  extra.forEach((input) => {\n    removeHiddenInputChangeEventListener(input);\n    input.remove();\n  });\n}\n\nfunction defaultSyncHiddenFormInput(\n  component: FormComponent,\n  input: HTMLInputElement,\n  value: string,\n): void {\n  const { defaultValue, disabled, form, name, required } = component;\n\n  // keep in sync to prevent losing reset value\n  input.defaultValue = defaultValue;\n  input.disabled = disabled;\n  input.name = name;\n  input.required = required;\n  input.tabIndex = -1;\n\n  // we set the attr as the prop is read-only\n  if (form) {\n    input.setAttribute(\"form\", form);\n  } else {\n    input.removeAttribute(\"form\");\n  }\n\n  if (isCheckable(component)) {\n    input.checked = component.checked;\n\n    // keep in sync to prevent losing reset value\n    input.defaultChecked = component.defaultChecked;\n    // heuristic to support default/on mode from https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default-on\n    input.value = component.checked ? value || \"on\" : \"\";\n  } else {\n    input.value = value || \"\";\n  }\n\n  component.syncHiddenFormInput?.(input);\n\n  const validationComponent = getValidationComponent(component.el as HTMLCalciteInputElement);\n\n  if (validationComponent && \"validity\" in validationComponent) {\n    // mutate the component's validity object to prevent a rerender\n    // https://stenciljs.com/docs/properties#mutable-arrays-and-objects\n    for (const key in { ...input?.validity }) {\n      validationComponent.validity[key] = input.validity[key];\n    }\n  }\n}\n\ninterface HiddenFormInputSlotProps {\n  component: FormComponent;\n}\n\n/**\n * Helper to render the slot for form-associated component's hidden input.\n *\n * If the component has a default slot, this must be placed at the bottom of the component's root container to ensure it is the last child.\n *\n * render(): VNode {\n *   <Host>\n *     <div class={CSS.container}>\n *     // ...\n *     <HiddenFormInputSlot component={this} />\n *     </div>\n *   </Host>\n * }\n *\n * Note that the hidden-form-input Sass mixin must be added to the component's style to apply specific styles.\n *\n * @param root0\n * @param root0.component\n */\nexport const HiddenFormInputSlot: FunctionalComponent<HiddenFormInputSlotProps> = ({\n  component,\n}): VNode => {\n  syncHiddenFormInput(component);\n\n  return <slot name={hiddenFormInputSlotName} />;\n};\n","export type InputComponent = NumericInputComponent | TextualInputComponent | DateTimeInputComponent;\n\nexport interface DateTimeInputComponent {\n  min: string;\n  max: string;\n}\n\nexport interface NumericInputComponent {\n  min: number;\n  max: number;\n  step: number | \"any\";\n}\n\nexport interface TextualInputComponent {\n  pattern?: string;\n  minLength: number;\n  maxLength: number;\n}\n\n/**\n * Exported for testing purposes only\n */\nexport const minMaxStepTypes = [\"date\", \"datetime-local\", \"month\", \"number\", \"range\", \"time\", \"week\"];\n\n/**\n * Exported for testing purposes only\n */\nexport const patternTypes = [\"email\", \"password\", \"search\", \"tel\", \"text\", \"url\"];\n\n/**\n * Exported for testing purposes only\n */\nexport const minMaxLengthTypes = [\"email\", \"password\", \"search\", \"tel\", \"text\", \"textarea\", \"url\"];\n\nfunction updateConstraintValidation(\n  inputComponent: InputComponent,\n  input: HTMLInputElement,\n  propName: string,\n  matchesType: boolean,\n): void {\n  const attributeName = propName.toLowerCase();\n  const value = inputComponent[propName];\n\n  if (matchesType && value != null) {\n    input.setAttribute(attributeName, `${value}`);\n  } else {\n    // we remove the attribute to ensure validation-constraints are properly reset\n    input.removeAttribute(attributeName);\n  }\n}\n\n/**\n * Synchronizes the hidden form input with the validation-related input properties.\n *\n * Note: loss of precision is expected due to the hidden input's value and validation-constraint props being strings.\n *\n * @param type - The input type.\n * @param inputComponent\n * @param hiddenFormInput\n */\nexport function syncHiddenFormInput(\n  type: HTMLInputElement[\"type\"] | \"textarea\",\n  inputComponent: InputComponent,\n  hiddenFormInput: HTMLInputElement,\n): void {\n  hiddenFormInput.type = type === \"textarea\" ? \"text\" : type;\n\n  const isMinMaxStepType = minMaxStepTypes.includes(type);\n  const numericInputComponent = inputComponent as NumericInputComponent;\n\n  updateConstraintValidation(numericInputComponent, hiddenFormInput, \"min\", isMinMaxStepType);\n  updateConstraintValidation(numericInputComponent, hiddenFormInput, \"max\", isMinMaxStepType);\n  updateConstraintValidation(numericInputComponent, hiddenFormInput, \"step\", isMinMaxStepType);\n\n  const isMinMaxLengthType = minMaxLengthTypes.includes(type);\n\n  const textualInputComponent = inputComponent as TextualInputComponent;\n\n  updateConstraintValidation(textualInputComponent, hiddenFormInput, \"minLength\", isMinMaxLengthType);\n  updateConstraintValidation(textualInputComponent, hiddenFormInput, \"maxLength\", isMinMaxLengthType);\n\n  const isPatternType = patternTypes.includes(type);\n\n  updateConstraintValidation(textualInputComponent, hiddenFormInput, \"pattern\", isPatternType);\n}\n","import { JSXAttributes } from \"@stencil/core/internal\";\nimport { FunctionalComponent, h, VNode } from \"@stencil/core\";\n\nexport interface InteractiveComponent {\n  /**\n   * The host element.\n   */\n  readonly el: InteractiveHTMLElement;\n\n  /**\n   * When true, prevents user interaction.\n   *\n   * Notes:\n   *\n   * This prop should use the @Prop decorator and reflect.\n   * The `disabled` Sass mixin must be added to the component's stylesheet.\n   */\n  disabled: boolean;\n}\n\n/**\n * Exported for testing purposes only.\n *\n * @internal\n */\nexport type InteractiveHTMLElement = HTMLElement & Pick<InteractiveComponent, \"disabled\">;\n\nfunction interceptedClick(): void {\n  const { disabled } = this as InteractiveHTMLElement;\n\n  if (!disabled) {\n    HTMLElement.prototype.click.call(this);\n  }\n}\n\nfunction onPointerDown(event: PointerEvent): void {\n  const interactiveElement = event.target as InteractiveHTMLElement;\n\n  if (interactiveElement.disabled) {\n    // prevent click from moving focus on host\n    event.preventDefault();\n  }\n}\n\nconst nonBubblingWhenDisabledMouseEvents = [\"mousedown\", \"mouseup\", \"click\"];\n\nfunction onNonBubblingWhenDisabledMouseEvent(event: MouseEvent): void {\n  const interactiveElement = event.target as InteractiveHTMLElement;\n\n  // prevent disallowed mouse events from being emitted on the disabled host (per https://github.com/whatwg/html/issues/5886)\n  // ⚠ we generally avoid stopping propagation of events, but this is needed to adhere to the intended spec changes above ⚠\n  if (interactiveElement.disabled) {\n    event.stopImmediatePropagation();\n    event.preventDefault();\n  }\n}\n\nconst captureOnlyOptions = { capture: true } as const;\n\n/**\n * This helper updates the host element to prevent keyboard interaction on its subtree and sets the appropriate aria attribute for accessibility.\n *\n * This should be used in the `componentDidRender` lifecycle hook.\n *\n * **Notes**\n *\n * this util is not needed for simple components whose root element or elements are an interactive component (custom element or native control). For those cases, set the `disabled` props on the root components instead.\n * technically, users can override `tabindex` and restore keyboard navigation, but this will be considered user error\n *\n * @param component\n */\nexport function updateHostInteraction(component: InteractiveComponent): void {\n  if (component.disabled) {\n    component.el.setAttribute(\"aria-disabled\", \"true\");\n\n    if (component.el.contains(document.activeElement)) {\n      (document.activeElement as HTMLElement).blur();\n    }\n\n    blockInteraction(component);\n\n    return;\n  }\n\n  restoreInteraction(component);\n\n  component.el.removeAttribute(\"aria-disabled\");\n}\n\nfunction blockInteraction(component: InteractiveComponent): void {\n  component.el.click = interceptedClick;\n  addInteractionListeners(component.el);\n}\n\nfunction addInteractionListeners(element: HTMLElement): void {\n  element.addEventListener(\"pointerdown\", onPointerDown, captureOnlyOptions);\n  nonBubblingWhenDisabledMouseEvents.forEach((event) =>\n    element.addEventListener(event, onNonBubblingWhenDisabledMouseEvent, captureOnlyOptions),\n  );\n}\n\nfunction restoreInteraction(component: InteractiveComponent): void {\n  delete component.el.click; // fallback on HTMLElement.prototype.click\n  removeInteractionListeners(component.el);\n}\n\nfunction removeInteractionListeners(element: HTMLElement): void {\n  element.removeEventListener(\"pointerdown\", onPointerDown, captureOnlyOptions);\n  nonBubblingWhenDisabledMouseEvents.forEach((event) =>\n    element.removeEventListener(event, onNonBubblingWhenDisabledMouseEvent, captureOnlyOptions),\n  );\n}\n\nexport interface InteractiveContainerProps extends JSXAttributes {\n  disabled: boolean;\n}\n\nexport const CSS = {\n  container: \"interaction-container\",\n};\n\nexport const InteractiveContainer: FunctionalComponent<InteractiveContainerProps> = (\n  { disabled },\n  children: VNode[],\n): VNode => (\n  <div class={CSS.container} inert={disabled}>\n    {...children}\n  </div>\n);\n","import { closestElementCrossShadowBoundary, isBefore, queryElementRoots } from \"./dom\";\nimport { componentOnReady } from \"./component\";\n\nexport interface LabelableComponent {\n  /**\n   * When true, disabled prevents interaction.\n   */\n  disabled: boolean;\n\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n\n  /**\n   * Text label.\n   */\n  label?: string;\n\n  /**\n   * The label this component is associated with.\n   */\n  labelEl: HTMLCalciteLabelElement;\n\n  /**\n   * Hook for components to provide custom label click behavior.\n   */\n  onLabelClick: (event: CustomEvent<any>) => void;\n}\n\n/**\n * Exported for testing purposes only\n *\n * @internal\n */\nexport const labelClickEvent = \"calciteInternalLabelClick\";\nexport const labelConnectedEvent = \"calciteInternalLabelConnected\";\nexport const labelDisconnectedEvent = \"calciteInternalLabelDisconnected\";\n\nconst labelTagName = \"calcite-label\";\nconst labelToLabelables = new WeakMap<HTMLCalciteLabelElement, LabelableComponent[]>();\nconst onLabelClickMap = new WeakMap<HTMLCalciteLabelElement, typeof onLabelClick>();\nconst onLabelConnectedMap = new WeakMap<LabelableComponent, typeof onLabelConnected>();\nconst onLabelDisconnectedMap = new WeakMap<LabelableComponent, typeof onLabelDisconnected>();\nconst unlabeledComponents = new Set<LabelableComponent>();\n\nconst findLabelForComponent = (componentEl: HTMLElement): HTMLCalciteLabelElement | null => {\n  const { id } = componentEl;\n\n  const forLabel =\n    id && queryElementRoots<HTMLCalciteLabelElement>(componentEl, { selector: `${labelTagName}[for=\"${id}\"]` });\n\n  if (forLabel) {\n    return forLabel;\n  }\n\n  const parentLabel = closestElementCrossShadowBoundary<HTMLCalciteLabelElement>(componentEl, labelTagName);\n\n  if (\n    !parentLabel ||\n    // labelable components within other custom elements are not considered labelable\n    hasAncestorCustomElements(parentLabel, componentEl)\n  ) {\n    return null;\n  }\n\n  return parentLabel;\n};\n\nfunction hasAncestorCustomElements(label: HTMLCalciteLabelElement, componentEl: HTMLElement): boolean {\n  let traversedElements: HTMLElement[];\n  const customElementAncestorCheckEventType = \"custom-element-ancestor-check\";\n\n  const listener = (event: CustomEvent) => {\n    event.stopImmediatePropagation();\n    const composedPath = event.composedPath() as HTMLElement[];\n    traversedElements = composedPath.slice(composedPath.indexOf(componentEl), composedPath.indexOf(label));\n  };\n\n  label.addEventListener(customElementAncestorCheckEventType, listener, { once: true });\n\n  componentEl.dispatchEvent(new CustomEvent(customElementAncestorCheckEventType, { composed: true, bubbles: true }));\n  label.removeEventListener(customElementAncestorCheckEventType, listener);\n\n  const ancestorCustomElements = traversedElements\n    .filter((el) => el !== componentEl && el !== label)\n    .filter((el) => el.tagName?.includes(\"-\"));\n\n  return ancestorCustomElements.length > 0;\n}\n\n/**\n * Helper to set up label interactions on connectedCallback.\n *\n * @param component\n */\nexport function connectLabel(component: LabelableComponent): void {\n  if (!component) {\n    return;\n  }\n\n  const labelEl = findLabelForComponent(component.el);\n\n  if (\n    (onLabelClickMap.has(labelEl) && labelEl === component.labelEl) ||\n    (!labelEl && unlabeledComponents.has(component))\n  ) {\n    return;\n  }\n\n  const boundOnLabelDisconnected = onLabelDisconnected.bind(component);\n\n  if (labelEl) {\n    component.labelEl = labelEl;\n\n    const labelables = labelToLabelables.get(labelEl) || [];\n    labelables.push(component);\n    labelToLabelables.set(labelEl, labelables.sort(sortByDOMOrder));\n\n    if (!onLabelClickMap.has(component.labelEl)) {\n      onLabelClickMap.set(component.labelEl, onLabelClick);\n      component.labelEl.addEventListener(labelClickEvent, onLabelClick);\n    }\n\n    unlabeledComponents.delete(component);\n    document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));\n    onLabelDisconnectedMap.set(component, boundOnLabelDisconnected);\n    document.addEventListener(labelDisconnectedEvent, boundOnLabelDisconnected);\n  } else if (!unlabeledComponents.has(component)) {\n    boundOnLabelDisconnected();\n    document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));\n  }\n}\n/**\n * Helper to tear down label interactions on disconnectedCallback on labelable components.\n *\n * @param component\n */\nexport function disconnectLabel(component: LabelableComponent): void {\n  if (!component) {\n    return;\n  }\n\n  unlabeledComponents.delete(component);\n  document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));\n  document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));\n  onLabelConnectedMap.delete(component);\n  onLabelDisconnectedMap.delete(component);\n\n  if (!component.labelEl) {\n    return;\n  }\n\n  const labelables = labelToLabelables.get(component.labelEl);\n\n  if (labelables.length === 1) {\n    component.labelEl.removeEventListener(labelClickEvent, onLabelClickMap.get(component.labelEl));\n    onLabelClickMap.delete(component.labelEl);\n  }\n\n  labelToLabelables.set(\n    component.labelEl,\n    labelables.filter((labelable) => labelable !== component).sort(sortByDOMOrder),\n  );\n\n  component.labelEl = null;\n}\n\nfunction sortByDOMOrder(a: LabelableComponent, b: LabelableComponent): number {\n  return isBefore(a.el, b.el) ? -1 : 1;\n}\n\n/**\n * Helper to get the label text from a component.\n *\n * @param component\n */\nexport function getLabelText(component: LabelableComponent): string {\n  return component.label || component.labelEl?.textContent?.trim() || \"\";\n}\n\nfunction onLabelClick(this: HTMLCalciteLabelElement, event: CustomEvent<{ sourceEvent: MouseEvent }>): void {\n  const labelClickTarget = event.detail.sourceEvent.target as HTMLElement;\n  const labelables = labelToLabelables.get(this);\n  const clickedLabelable = labelables.find((labelable) => labelable.el === labelClickTarget);\n  const labelableChildClicked = labelables.includes(clickedLabelable);\n\n  if (labelableChildClicked) {\n    // no need to forward click as labelable will receive focus\n    return;\n  }\n\n  const firstLabelable = labelables[0];\n\n  if (firstLabelable.disabled) {\n    return;\n  }\n\n  firstLabelable.onLabelClick(event);\n}\n\nfunction onLabelConnected(this: LabelableComponent): void {\n  if (unlabeledComponents.has(this)) {\n    connectLabel(this);\n  }\n}\n\nfunction onLabelDisconnected(this: LabelableComponent): void {\n  unlabeledComponents.add(this);\n  const boundOnLabelConnected = onLabelConnectedMap.get(this) || onLabelConnected.bind(this);\n  onLabelConnectedMap.set(this, boundOnLabelConnected);\n  document.addEventListener(labelConnectedEvent, boundOnLabelConnected);\n}\n\n/**\n * Helper to associate an explicit label (i.e., using `for`) with a labelable component that does not have an associated label.\n *\n * @param label - the label element\n */\nexport async function associateExplicitLabelToUnlabeledComponent(label: HTMLCalciteLabelElement): Promise<void> {\n  await componentOnReady(label);\n\n  const alreadyLabeled = labelToLabelables.has(label);\n\n  if (alreadyLabeled) {\n    return;\n  }\n\n  const forComponentEl = label.ownerDocument?.getElementById(label.for);\n\n  if (!forComponentEl) {\n    return;\n  }\n\n  requestAnimationFrame(() => {\n    for (const labelable of unlabeledComponents) {\n      if (labelable.el === forComponentEl) {\n        connectLabel(labelable);\n        break;\n      }\n    }\n  });\n}\n","import { getAssetPath } from \"@stencil/core\";\nimport { getSupportedLocale, LocalizedComponent } from \"./locale\";\nimport { isBrowser } from \"./browser\";\n\nexport type MessageBundle = Record<string, string>;\n\nexport const componentLangToMessageBundleCache: Record<string, Promise<MessageBundle>> = {};\n\nasync function getMessageBundle(lang: string, component: string): Promise<MessageBundle> {\n  const key = `${component}_${lang}`;\n\n  if (componentLangToMessageBundleCache[key]) {\n    return componentLangToMessageBundleCache[key];\n  }\n\n  componentLangToMessageBundleCache[key] = fetch(getAssetPath(`./assets/${component}/t9n/messages_${lang}.json`))\n    .then((resp) => {\n      if (!resp.ok) {\n        throwMessageFetchError();\n      }\n      return resp.json();\n    })\n    .catch(() => throwMessageFetchError());\n\n  return componentLangToMessageBundleCache[key];\n}\n\nfunction throwMessageFetchError(): never {\n  throw new Error(\"could not fetch component message bundle\");\n}\n\nfunction mergeMessages(component: T9nComponent): void {\n  component.messages = {\n    ...component.defaultMessages,\n    ...component.messageOverrides,\n  };\n}\n\nfunction noop(): void {\n  // intentionally empty\n}\n\n/**\n * This utility sets up the messages used by the component. It should be awaited in the `componentWillLoad` lifecycle hook.\n *\n * @param component\n */\nexport async function setUpMessages(component: T9nComponent): Promise<void> {\n  component.defaultMessages = await fetchMessages(component, component.effectiveLocale);\n  mergeMessages(component);\n}\n\nasync function fetchMessages(component: T9nComponent, lang: string): Promise<MessageBundle> {\n  if (!isBrowser()) {\n    return {};\n  }\n\n  const { el } = component;\n  const tag = el.tagName.toLowerCase();\n  const componentName = tag.replace(\"calcite-\", \"\");\n\n  return getMessageBundle(getSupportedLocale(lang, \"t9n\"), componentName);\n}\n\n/**\n * This utility must be set up for the component to update its default message bundle if the locale changes.\n *\n * It can be set up in **either** of the following ways:\n *\n * 1. called from `LocalizedComponent`'s `onLocaleChange` method or\n * 2. called from a watcher configured to watch `LocalizedComponent`'s `effectiveLocale` prop\n *\n * @param component\n * @param lang\n */\nexport async function updateMessages(component: T9nComponent, lang: string): Promise<void> {\n  component.defaultMessages = await fetchMessages(component, lang);\n  mergeMessages(component);\n}\n\n/**\n * This utility sets up internals for messages support.\n *\n * It needs to be called in `connectedCallback`\n *\n * **Note**: this must be called after `LocalizedComponent`'s `connectLocalized` method.\n *\n * @param component\n */\nexport function connectMessages(component: T9nComponent): void {\n  component.onMessagesChange = defaultOnMessagesChange;\n}\n\n/**\n * This utility tears down internals for messages support.\n *\n * It needs to be called in `disconnectedCallback`\n *\n * @param component\n */\nexport function disconnectMessages(component: T9nComponent): void {\n  // we set this to noop to for watchers triggered when components are disconnected\n  component.onMessagesChange = noop;\n}\n\n/**\n * This interface enables components to support built-in translation strings.\n *\n * **Notes**:\n *\n * This requires `LocalizedComponent` to be implemented.\n * To avoid unnecessary lookups, composite components should set `lang` on internal t9n components.\n */\nexport interface T9nComponent extends LocalizedComponent {\n  el: HTMLElement;\n\n  /**\n   * This property holds all messages used by the component's rendering.\n   *\n   * This prop should use the `@Prop` decorator. It uses `@Prop` decorator for testing purpose only.\n   */\n  messages: MessageBundle;\n\n  /**\n   * This property holds the component's default messages.\n   */\n  defaultMessages: MessageBundle;\n\n  /**\n   * This property holds all user message overrides.\n   *\n   * This prop should use the `@Prop` decorator.\n   */\n  messageOverrides: Partial<MessageBundle>;\n\n  /**\n   * This private method ensures messages are kept in sync.\n   *\n   * This method should be empty and configured to watch for changes on  `messageOverrides` property.\n   *\n   * @Watch(\"messageOverrides\")\n   * onMessagesChange(): void {\n   *  \\/* wired up by t9n util *\\/\n   * }\n   */\n  onMessagesChange: () => void;\n}\n\nfunction defaultOnMessagesChange(this: T9nComponent): void {\n  mergeMessages(this);\n}\n"],"names":["CSS","Validation","_ref","scale","status","id","icon","message","h","class","getIconScale","componentScale","async","componentOnReady","el","isStencilEl","Promise","resolve","requestAnimationFrame","componentsWithInputEvent","hiddenFormInputSlotName","isCheckable","component","onFormResetMap","WeakMap","formComponentSet","WeakSet","getValidationComponent","nodeName","closestElementCrossShadowBoundary","invalidEvent","CustomEvent","bubbles","composed","invalidHandler","event","hiddenInput","target","hiddenInputMessage","validationMessage","formComponent","parentElement","componentTag","toLowerCase","componentTagParts","split","length","preventDefault","validity","dispatchEvent","validationIcon","displayValidationMessage","clearValidationEvent","map","part","index","toUpperCase","slice","join","includes","getClearValidationEventName","addEventListener","once","submitForm","formEl","requestSubmit","removeEventListener","invalidEls","querySelectorAll","setFocus","resetForm","reset","connectForm","value","associatedForm","findAssociatedForm","form","formComponentEl","formComponentRegisterEventName","hasRegisteredFormComponentParent","composedPath","some","element","has","stopPropagation","defaultValue","defaultChecked","checked","boundOnFormReset","onFormReset","bind","set","add","queryElementRoots","this","disconnectForm","get","delete","afterConnectDefaultValueSet","internalHiddenInputInputEvent","hiddenInputInputHandler","removeHiddenInputChangeEventListener","input","defaultSyncHiddenFormInput","disabled","name","required","tabIndex","setAttribute","removeAttribute","syncHiddenFormInput","validationComponent","key","HiddenFormInputSlot","_ref2","ownerDocument","inputs","forEach","remove","values","Array","isArray","extra","seen","Set","docFrag","valueMatch","find","val","push","pop","createElement","slot","createDocumentFragment","append","minMaxStepTypes","patternTypes","minMaxLengthTypes","updateConstraintValidation","inputComponent","propName","matchesType","attributeName","type","hiddenFormInput","isMinMaxStepType","numericInputComponent","isMinMaxLengthType","textualInputComponent","interceptedClick","HTMLElement","prototype","click","call","onPointerDown","nonBubblingWhenDisabledMouseEvents","onNonBubblingWhenDisabledMouseEvent","stopImmediatePropagation","captureOnlyOptions","capture","updateHostInteraction","contains","document","activeElement","blur","blockInteraction","restoreInteraction","InteractiveContainer","children","inert","labelClickEvent","labelConnectedEvent","labelDisconnectedEvent","labelTagName","labelToLabelables","onLabelClickMap","onLabelConnectedMap","onLabelDisconnectedMap","unlabeledComponents","findLabelForComponent","componentEl","forLabel","selector","parentLabel","label","traversedElements","customElementAncestorCheckEventType","listener","indexOf","ancestorCustomElements","filter","tagName","hasAncestorCustomElements","connectLabel","labelEl","boundOnLabelDisconnected","onLabelDisconnected","labelables","sort","sortByDOMOrder","onLabelClick","disconnectLabel","labelable","a","b","isBefore","getLabelText","textContent","trim","labelClickTarget","detail","sourceEvent","clickedLabelable","firstLabelable","onLabelConnected","boundOnLabelConnected","associateExplicitLabelToUnlabeledComponent","forComponentEl","getElementById","for","componentLangToMessageBundleCache","throwMessageFetchError","Error","mergeMessages","messages","defaultMessages","messageOverrides","noop","setUpMessages","fetchMessages","effectiveLocale","lang","isBrowser","componentName","replace","fetch","getAssetPath","then","resp","ok","json","catch","getMessageBundle","getSupportedLocale","updateMessages","connectMessages","onMessagesChange","defaultOnMessagesChange","disconnectMessages"],"sourceRoot":""}