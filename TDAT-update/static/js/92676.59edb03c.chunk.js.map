{"version":3,"file":"static/js/92676.59edb03c.chunk.js","mappings":"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","sources":["../node_modules/@arcgis/charts-components/dist/esm/charts-bar-chart-d2db27a3.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See LICENSE.md for details.\n * v4.31.1\n */\nimport { r as registerInstance, c as createEvent, h, H as Host, a as getElement } from './index-a70f9e3a.js';\nimport { H as HTMLClasses, u as updateLegendPosition, b as updateLegendVisibility, r as resetAxesBounds, f as fetchErrorsStrings, c as fetchCommonStrings, p as promise, g as gatherComponentOptions, l as addMissingSplitBySeries, d as gatherComponentGlobalOptions, m as maximumNumberOfSimultaneousUpdates, i as isValidDataSource, e as addLayerFilterListener, h as addLayerRendererListener, j as addExtentChangeListener, z as zY, k as ArcgisChartsNotifyPanel } from './config-update-5d4b05b1.js';\nimport { L as Lm, A as Am, E as Em, x as xn, M as Mc, W as WebChartTypes, b as El, u as updateActionBarStates, S as Slot, o as onActionBarSlotChange, j as jc, e as WebChartVersionStatus, K as Kr, t as ta } from './action-bar-utils-537f9a25.js';\n\nconst chartsBarChartCss = \".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.barSeries{flex-grow:1;overflow-y:hidden}.barSeries>div{justify-content:center;align-items:center}.barSeries .arcgis-charts-modal-inside{padding:1em;padding-left:0}.barSeries .arcgis-charts-modal-inside ol{padding-left:2em}.barSeries .arcgis-charts-modal-curtain{width:100%;height:100%;position:absolute;top:0px;left:0px;z-index:2001;background-color:rgb(255, 255, 255);opacity:0.5;opacity:1}.barSeries .arcgis-charts-modal-content{background:rgba(255, 255, 255, 0.8);color:rgb(0, 0, 0);display:inline-block;position:absolute;top:0px;left:0px;max-width:90%;max-height:90%;overflow:visible;z-index:2002;position:absolute;max-width:90%;max-height:90%;width:auto !important;height:auto !important;margin:auto !important;inset:auto !important;left:auto !important;top:auto !important}.barSeries .arcgis-charts-modal-header{display:block;width:100%;min-height:1.8em;background:rgba(0, 0, 0, 0.05)}.barSeries .arcgis-charts-modal-close{display:block;position:absolute;top:0.3em;right:0.3em;background:url(\\\"data:image/svg+xml;charset=utf-8;base64,PHN2ZyBoZWlnaHQ9IjUxMiIgdmVyc2lvbj0iMSIgdmlld0JveD0iMCAwIDUxMiA1MTIiIHdpZHRoPSI1MTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQ0NS4yIDEwOS4ybC00Mi40LTQyLjRMMjU2IDIxMy42IDEwOS4yIDY2LjhsLTQyLjQgNDIuNEwyMTMuNiAyNTYgNjYuOCA0MDIuOGw0Mi40IDQyLjRMMjU2IDI5OC40bDE0Ni44IDE0Ni44IDQyLjQtNDIuNEwyOTguNCAyNTYiLz48L3N2Zz4=\\\") center center/80% no-repeat rgba(100, 100, 100, 0.1);width:1.2em;height:1.2em;cursor:pointer}.barSeries .arcgis-charts-modal-title{font-weight:bold;font-size:110%;padding:0.5em 1.2em 0.5em 1em}:host{width:var(--charts-bar-chart-width, var(--arcgis-charts-default-width));height:var(--charts-bar-chart-height, var(--arcgis-charts-default-height));display:flex;flex-direction:row}\";\nconst ArcgisChartsBarChartStyle0 = chartsBarChartCss;\n\nconst ArcGISChartsBarChart = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.arcgisRuntimeError = createEvent(this, \"arcgisRuntimeError\", 7);\n        this.arcgisDataProcessError = createEvent(this, \"arcgisDataProcessError\", 7);\n        this.arcgisDataProcessComplete = createEvent(this, \"arcgisDataProcessComplete\", 7);\n        this.arcgisLegendItemVisibilityChange = createEvent(this, \"arcgisLegendItemVisibilityChange\", 7);\n        this.arcgisUpdateComplete = createEvent(this, \"arcgisUpdateComplete\", 7);\n        this.arcgisBadDataWarningRaise = createEvent(this, \"arcgisBadDataWarningRaise\", 7);\n        this.arcgisSeriesColorChange = createEvent(this, \"arcgisSeriesColorChange\", 7);\n        this.arcgisAxesMinMaxChange = createEvent(this, \"arcgisAxesMinMaxChange\", 7);\n        this.arcgisSelectionComplete = createEvent(this, \"arcgisSelectionComplete\", 7);\n        this.arcgisNoRenderPropChange = createEvent(this, \"arcgisNoRenderPropChange\", 7);\n        this.arcgisSeriesOrder = createEvent(this, \"arcgisSeriesOrder\", 7);\n        /**\n         * When `true`, the next round of update will be skipped.\n         * @type {boolean}\n         * @category Private\n         * @default false\n         */\n        this.skipNextUpdate = false;\n        /**\n         * List of props which should not trigger a render when changed\n         * @type {string[]}\n         * @category Private\n         */\n        this.noRenderProps = [\"disableInteractions\", \"rotation\", \"legendPosition\", \"legendVisibility\", \"view\"];\n        /**\n         * List of props which should trigger a data update\n         * @type {string[]}\n         * @category Private\n         */\n        this.dataUpdateNeededProps = [\"forceDataUpdate\", \"runtimeDataFilters\", \"returnFeaturesExtent\"];\n        /**\n         * List of all the properties updated since the last update. Useful when multiple properties are updated\n         * within the same time frame, while some of them require some extra logic to be applied.\n         * @type {Set<string>}\n         * @category Private\n         */\n        this.updatedProps = new Set();\n        this.config = undefined;\n        this.rotation = undefined;\n        this.actionMode = undefined;\n        this.cursorRange = undefined;\n        this.legendPosition = undefined;\n        this.legendVisibility = undefined;\n        this.hideEmptySeries = undefined;\n        this.timeZone = undefined;\n        this.view = undefined;\n        this.layer = undefined;\n        this.selectionData = undefined;\n        this.returnSelectionOIDs = undefined;\n        this.returnSelectionIndexes = undefined;\n        this.returnFeaturesExtent = undefined;\n        this.filterBySelection = undefined;\n        this.disableInteractions = undefined;\n        this.queueChartCreation = undefined;\n        this.useAnimatedCharts = undefined;\n        this.hideLicenceWatermark = undefined;\n        this.enableResponsiveFeatures = undefined;\n        this.autoDisposeChart = undefined;\n        this.placeholder = undefined;\n        this.selectionTheme = undefined;\n        this.setTimeBinningInfoWhenNotProvided = undefined;\n        this.chartLimits = undefined;\n        this.tooltipFormatter = undefined;\n        this.dataLabelFormatter = undefined;\n        this.guideTooltipFormatter = undefined;\n        this.xAxisLabelFormatter = undefined;\n        this.yAxisLabelFormatter = undefined;\n        this.messageOptions = undefined;\n        this.errorPolicy = Lm.Throw;\n        this.disableTogglingLegendItems = undefined;\n        this.hideLoaderAnimation = undefined;\n        this.runtimeDataFilters = undefined;\n        this.usePopupTemplateFieldsInfo = undefined;\n        this.layerFilterChangePolicy = Am.Refresh;\n        this.layerRendererChangePolicy = Em.Refresh;\n        this.ignoreViewExtent = undefined;\n        this.updateSplitBySeries = undefined;\n        this.showNotifyPanel = false;\n    }\n    /**\n     * Listener on event coming from the chart container indicating the chart data has been processed\n     * emitting an event carrying the data\n     * @param {CustomEvent<WebChartGenericDataItem>} event The event carrying the chart data processed by the core\n     * @category Custom-event handler\n     */\n    handleChartOutputDataChange(event) {\n        this.arcgisDataProcessComplete.emit(event.detail);\n    }\n    /**\n     * Listener on event coming from the chart container indicating a legend item visibility has been changed\n     * emitting an event carrying the item id and its new visibility\n     * @param {CustomEvent} event The event carrying the item id and its new visibility\n     * @category Custom-event handler\n     */\n    handleLegendItemVisibilityChanged(event) {\n        this.arcgisLegendItemVisibilityChange.emit(event.detail);\n    }\n    /**\n     * Listener on event coming from the chart container indicating a chart is updated\n     * @param {CustomEvent} event The event carrying the ValidationStatus\n     * @category Custom-event handler\n     */\n    handleUpdateCompleted(event) {\n        this.arcgisUpdateComplete.emit(event.detail);\n    }\n    /**\n     * Listener on event coming from the chart container indicating an error in the data set\n     * @param {CustomEvent} event The event carrying details about the error\n     * @category Custom-event handler\n     */\n    handleBadDataWarningRaise(event) {\n        this.arcgisBadDataWarningRaise.emit(event.detail);\n    }\n    /**\n     * Listener on event coming from the chart container indicating the chart series color\n     * have been assigned\n     * @param {CustomEvent<SeriesSymbolsMap>} event The event carrying the series colors\n     * @category Custom-event handler\n     */\n    handleSeriesColorsChange(event) {\n        this.arcgisSeriesColorChange.emit(event.detail);\n    }\n    /**\n     * Listener on event coming from the chart container\n     * on selection of one or multiple columns\n     * @param {CustomEvent<SelectionData>} event The event carrying the selected elements\n     * @category Custom-event handler\n     */\n    handleSelection(event) {\n        this.arcgisSelectionComplete.emit(event.detail);\n    }\n    /**\n     * Listener on event coming from the chart container\n     * when more elements than the authorized limit have been selected.\n     * @category Custom-event handler\n     */\n    handleTooManySelectedElements() {\n        if (this.errorPolicy === Lm.Throw) {\n            this.notifyHeading = this.errorStrings.tooManySelectedElements.title;\n            this.notifyMessage = this.errorStrings.tooManySelectedElements.message;\n            this.notifyOptions = {\n                kind: \"warning\",\n                autoClose: true,\n                duration: \"fast\",\n                active: true,\n            };\n            this.showNotifyPanel = true;\n        }\n    }\n    /**\n     * Listener on event coming from the closure of a calcite-alert.\n     * The handler helps keeping in sync the boolean `showNotifyPanel` with the panel's state.\n     * @param {CustomEvent} event\n     * @category Custom-event handler\n     */\n    handleAlertClosed(event) {\n        // If the calcite-alert (notify panel) from this component is getting closed, we flag it\n        if (event.target === this.el) {\n            // we don't want the component to re-render so we skip the next update\n            this.skipNextUpdate = true;\n            this.showNotifyPanel = false;\n        }\n    }\n    /**\n     * Listener on event coming from the chart container indicating the chart axes\n     * min and max values have been computed\n     * @param {CustomEvent} event The event carrying the axes min and max\n     * @category Custom-event handler\n     */\n    handleAxesMinMaxChange(event) {\n        this.arcgisAxesMinMaxChange.emit(event.detail);\n    }\n    /**\n     * Listener on event coming from the chart container indicating a the series order changed on the chart.\n     * @param event The event carrying a list of series id as they are visually ordered on the chart\n     * @category Custom-event handler\n     */\n    handleSeriesOrder(event) {\n        this.arcgisSeriesOrder.emit(event.detail);\n    }\n    /**\n     * Called every time the view prop is updated.\n     * Add a listener to it to keep the chart in sync.\n     * @param {MapView | SceneView | undefined} newView The new view\n     * @param {MapView | SceneView | undefined} oldView The old view\n     * @category Watch handler\n     */\n    async viewChange(newView, oldView) {\n        await this.setExtentChangeListener();\n        // The \"view\" property is flagged as a non-render prop to avoid an unnecessary update when the\n        // view is assigned to the component (the update will happen through the view listeners), so we\n        // only need to explicitly ask for a refresh when the view is removed from the component\n        if (oldView !== undefined && newView === undefined) {\n            await this.refresh();\n        }\n    }\n    /**\n     * Called every time the layer prop is updated.\n     * Adds listeners to it to keep the chart in sync.\n     * @category Watch handler\n     */\n    async layerChange() {\n        await this.addLayerListeners();\n    }\n    /**\n     * Called every time the `runtimeDataFilters` prop is updated.\n     * The property name is added to the `updatedProps` list in order to trigger later a data update.\n     * The mechanism is also done by `componentShouldUpdate` but doesn't always work when multiple properties are\n     * updated at the same time (e.g. only 1 `componentShouldUpdate` is called while 2 properties were changed).\n     * For that reason all the properties implying a data update (see this.dataUpdateNeededProps) need a @Watch\n     * to ensure the chart update to consider them properly.\n     * Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/6095\n     * @category Watch handler\n     */\n    async runtimeDataFiltersChange() {\n        this.updatedProps.add(\"runtimeDataFilters\");\n    }\n    /**\n     * Called every time the `returnFeaturesExtent` prop is updated.\n     * The property name is added to the `updatedProps` list in order to trigger later a data update.\n     * The mechanism is also done by `componentShouldUpdate` but doesn't always work when multiple properties are\n     * updated at the same time (e.g. only 1 `componentShouldUpdate` is called while 2 properties were changed).\n     * For that reason all the properties implying a data update (see this.dataUpdateNeededProps) need a @Watch\n     * to ensure the chart update to consider them properly.\n     * Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/6095\n     * @category Watch handler\n     */\n    async returnFeaturesExtentChange() {\n        this.updatedProps.add(\"returnFeaturesExtent\");\n    }\n    /**\n     * Called every time the disableInteractions prop is updated.\n     * Helps setting a css class on the chart to either enable or disable the chart interactions.\n     * @param {boolean} newValue\n     */\n    async disableInteractionsChange(newValue) {\n        // Toggling the interactions only for Firefox. (see issue #2466 for more details)\n        if (navigator.userAgent.search(\"Firefox\") !== -1) {\n            if (newValue) {\n                this.chartRef?.classList.add(HTMLClasses.DisableInteractions);\n            }\n            else {\n                this.chartRef?.classList.remove(HTMLClasses.DisableInteractions);\n            }\n        }\n    }\n    /**\n     * Called every time the rotation property is updated\n     * @param {boolean} newRotation The new rotation value for the chart\n     * @category Watch handler\n     */\n    rotationChange(newRotation) {\n        this.config = xn(newRotation, this.config);\n    }\n    /**\n     * Called every time the position of the legend is updated\n     * @param {WebChartLegendPositions} newLegendPosition The new position of the legend\n     * @category Watch handler\n     */\n    legendPositionChange(newLegendPosition) {\n        this.config = updateLegendPosition(newLegendPosition, this.config);\n    }\n    /**\n     * Called every time the visibility of the legend is updated\n     * @param {boolean} newLegendVisibility The new visibility of the legend\n     * @category Watch handler\n     */\n    legendVisibilityChange(newLegendVisibility) {\n        this.config = updateLegendVisibility(newLegendVisibility, this.config);\n    }\n    /**\n     * Called every time the time zone is updated\n     * @category Watch handler\n     */\n    timeZoneChange() {\n        this.updateConfigTimeZone();\n    }\n    /**\n     * Called every time the filter by selection is updated.\n     * Resets the axes min/max.\n     * @category Watch handler\n     */\n    filterBySelectionChanged() {\n        this.config = resetAxesBounds(this.config);\n    }\n    /**\n     * Called every time when the property `layerFilterChangePolicy` changes\n     * Adds a listener on the layer's filter when the property is `true`, removes it otherwise.\n     * @param {LayerFilterChangePolicy | undefined} newRefreshOnLayerFilter The new value of refresh on layer filter\n     * @category Watch handler\n     */\n    layerFilterChangePolicyCallBack(newRefreshOnLayerFilter) {\n        if (newRefreshOnLayerFilter !== Am.Ignore) {\n            this.setLayerFilterListener();\n        }\n        else {\n            this.removeLayerFilterListener();\n        }\n    }\n    /**\n     * Called every time when the property `layerRendererChangePolicy` changes\n     * Adds a listener on the layer's renderer when the property is `true`, removes it otherwise.\n     * @param {LayerRendererChangePolicy | undefined} newRefreshOnLayerRenderer The new value of refresh on layer renderer\n     * @category Watch handler\n     */\n    layerRendererChangePolicyCallBack(newRefreshOnLayerRenderer) {\n        if (newRefreshOnLayerRenderer !== Em.Ignore) {\n            this.setLayerRendererListener();\n        }\n        else {\n            this.removeLayerRendererListener();\n        }\n    }\n    /**\n     * Notify method allows passing external messages to the chart component.\n     * It can be used to pass validation or information messages.\n     * In a situation where a config update is overriding your notification modal,\n     * consider waiting for the `arcgisUpdateComplete` event.\n     * @category Public\n     * @param {string} [message] The message to display in the notification panel.\n     * @param {string} [heading] The heading to display in the notification panel.\n     * @param {NotifyOptions} [options] The options to apply to the notification panel.\n     */\n    async notify(message, heading, options) {\n        if (this.chart !== undefined) {\n            this.chart.notify(message, heading, options);\n        }\n        await Promise.resolve(undefined);\n    }\n    /**\n     * Triggers an alert to display an error message.\n     * @category Public\n     * @param {string | undefined} [errorMessage]\n     */\n    async errorAlert(errorMessage) {\n        if (this.errorPolicy === Lm.Throw) {\n            this.notifyHeading = this.errorStrings.errorHeading;\n            this.notifyMessage = errorMessage;\n            this.notifyOptions = {\n                kind: \"danger\",\n                autoClose: true,\n                active: true,\n            };\n            this.showNotifyPanel = true;\n        }\n    }\n    /**\n     * Resets the chart zoom to bring it back to full extent\n     * @category Public\n     */\n    async resetZoom() {\n        if (this.chart !== undefined) {\n            this.chart.resetZoom();\n        }\n        await Promise.resolve(undefined);\n    }\n    /**\n     * Switches the selection on the chart.\n     * @category Public\n     */\n    async switchSelection() {\n        // for now we don't allow the switch selection when the filter by selection is on\n        if (this.chart !== undefined && this.filterBySelection !== true) {\n            await this.chart.switchSelection();\n        }\n    }\n    /**\n     * Clears all selection on the chart.\n     * @category Public\n     */\n    async clearSelection() {\n        if (this.chart !== undefined) {\n            this.chart.clearSelection();\n            // to handle the full data reset we call the componentDidUpdate to trigger a chart update\n            if (this.filterBySelection === true) {\n                await this.refresh();\n            }\n        }\n    }\n    /**\n     * Re-render the chart.\n     * @param {boolean} [props.updateData] Indicates whether to fetch new data. Default: true.\n     * @param {boolean} [props.updateExtent] Indicates whether the view's extent is to update. Default: false.\n     * @param {boolean} [props.resetAxesBounds] Option to reset the axes bounds along with the refresh. Default: false;\n     * @category Public\n     */\n    async refresh(props) {\n        const { updateData = true, resetAxesBounds = false, updateExtent = false } = props ?? {};\n        //  Adds a property into `updatedProps` so the debouncedChartUpdate triggers the update\n        this.updatedProps.add(updateData ? \"forceDataUpdate\" : \"forceSimpleUpdate\");\n        this.viewExtentUpdated = updateExtent;\n        // Resetting the axes bounds\n        if (resetAxesBounds) {\n            delete this.config?.axes?.[0]?.minimum;\n            delete this.config?.axes?.[0]?.maximum;\n            delete this.config?.axes?.[1]?.minimum;\n            delete this.config?.axes?.[1]?.maximum;\n        }\n        await this.componentDidUpdate();\n        // reset the boolean for the next update\n        this.viewExtentUpdated = false;\n    }\n    /**\n     * Prevents render for noRenderProps\n     * @category Lifecycle\n     */\n    componentShouldUpdate(...args) {\n        const [value, , propName] = args;\n        // Flagging the property. This list will be used when the chart update is actually called.\n        this.updatedProps.add(propName);\n        const isNoRenderProp = this.noRenderProps.includes(propName);\n        if (isNoRenderProp) {\n            this.arcgisNoRenderPropChange.emit({ propName, value });\n        }\n        const shouldUpdate = !this.skipNextUpdate && !isNoRenderProp;\n        this.skipNextUpdate = false;\n        return shouldUpdate;\n    }\n    /**\n     * @category Lifecycle\n     */\n    async componentWillLoad() {\n        this.errorStrings = await fetchErrorsStrings(this.el);\n        this.commonStrings = await fetchCommonStrings(this.el);\n        // We define the function that will be called to update the chart. We use the external library fastq to queue the updates\n        // to make sure only one update is executed at a time\n        this.debouncedChartUpdate = promise(async () => {\n            if (this.chart !== undefined) {\n                const updatedProps = Array.from(this.updatedProps);\n                if (updatedProps.length > 0) {\n                    // if one of the properties updated require a data update, we flag it\n                    // multiple properties can be updated within the same time frame, which will trigger only one Stencil lifecycle\n                    const dataUpdateNeeded = updatedProps.some((updatedProp) => this.dataUpdateNeededProps.includes(updatedProp));\n                    // clearing the list for the next update\n                    this.updatedProps.clear();\n                    const updateOptions = gatherComponentOptions({\n                        component: this,\n                        dataUpdated: dataUpdateNeeded,\n                        viewExtentUpdated: this.viewExtentUpdated,\n                    });\n                    // As long as `addMissingSeries` is true, we try to complete the config with missing series\n                    if (this.updateSplitBySeries?.addMissingSeries === true) {\n                        await addMissingSplitBySeries(this, updateOptions);\n                    }\n                    await this.chart.update({\n                        newChartConfig: this.config,\n                        updateOptions,\n                        updateGlobalOptions: gatherComponentGlobalOptions(this),\n                        t9nStrings: {\n                            errorStrings: this.errorStrings,\n                            commonStrings: this.commonStrings,\n                        },\n                    });\n                }\n                await Promise.resolve(undefined);\n            }\n        }, maximumNumberOfSimultaneousUpdates);\n    }\n    /**\n     * @category Lifecycle\n     */\n    async componentDidLoad() {\n        if (this.chartRef !== undefined) {\n            await this.createChartInstance();\n        }\n    }\n    /**\n     * @category Lifecycle\n     */\n    async componentDidUpdate() {\n        // If this.chartCreationProcessing is still running we need to wait for it to be done before updating the chart\n        if (this.chart === undefined && this.chartCreationProcessing !== undefined) {\n            await this.chartCreationProcessing;\n            this.chartCreationProcessing = undefined;\n        }\n        // Controlling the series type to display a console error if the type is not the expected one\n        // We still proceed to the update to let the config validator deal with the invalid config\n        await Mc([WebChartTypes.BarSeries], this.config);\n        if (this.config !== undefined && this.chart !== undefined && !this.showNotifyPanel) {\n            try {\n                // Calling for the chart update if the data source is valid\n                if (isValidDataSource(this.config, this.layer)) {\n                    await this.debouncedChartUpdate.push();\n                }\n            }\n            catch (e) {\n                if (this.chartRef !== undefined) {\n                    if (e.name === El.ChartDisposed) {\n                        this.chart.dispose();\n                        this.chart = undefined;\n                        this.chartRef.innerHTML = \"\";\n                        await this.createChartInstance(false);\n                    }\n                    else {\n                        // sending an event when error occurs.\n                        // We don't automatically recreate the chart in that scenario as it would lead to the same result.\n                        if (e.name === El.QueryFeaturesError) {\n                            this.arcgisDataProcessError.emit(e.details);\n                        }\n                        else {\n                            this.arcgisRuntimeError.emit(e.details ?? e);\n                        }\n                        // displaying the error\n                        this.errorAlert(e?.message);\n                    }\n                }\n            }\n        }\n        else if (this.chart === undefined && this.chartCreationProcessing === undefined && !this.showNotifyPanel) {\n            await this.createChartInstance();\n        }\n        else if (this.placeholder !== undefined) {\n            this.notify(this.placeholder);\n        }\n        // Update the action bar states since the relevant properties may have changed\n        if (this.actionBarElement !== undefined) {\n            updateActionBarStates(this.actionBarElement, this.config);\n        }\n    }\n    /**\n     * Called when the component is removed from the DOM.\n     * @category Lifecycle\n     */\n    async disconnectedCallback() {\n        this.removeLayerListeners();\n        this.removeExtentChangeListeners();\n        if (this.chart !== undefined) {\n            this.chart.dispose();\n        }\n    }\n    /**\n     * @category Lifecycle\n     */\n    render() {\n        const notifyPanel = this.showNotifyPanel ? (h(ArcgisChartsNotifyPanel, { heading: this.notifyHeading, message: this.notifyMessage, options: this.notifyOptions })) : null;\n        // TODO: implement stronger way to know when to keep the chart visible\n        const chartStyles = this.showNotifyPanel && this.notifyOptions?.kind === \"danger\"\n            ? HTMLClasses.Hide\n            : `${WebChartTypes.BarSeries} ${HTMLClasses.Show}`;\n        const notifyStyles = this.showNotifyPanel ? `${HTMLClasses.Show} ${HTMLClasses.NotifyPanel}` : HTMLClasses.Hide;\n        return (h(Host, { key: 'a542c82c3aae570cb0f4f560448f793ac5c42ba1' }, h(\"slot\", { key: '4f9afb8f19681e524c788d4bba5745273c43d785', name: Slot.actionBar, onSlotchange: (e) => {\n                onActionBarSlotChange(e, WebChartTypes.BarSeries, this.config);\n            }, ref: (el) => {\n                this.actionBarElement = el;\n            } }), h(\"div\", { key: '8c8809d062c01092fddf756eebaa1b91ea6afd52', class: chartStyles, ref: (el) => {\n                this.chartRef = el;\n            } }), h(\"div\", { key: 'cc61e0b06b128fec89b5bdd23a86fb48985b8450', class: notifyStyles }, notifyPanel)));\n    }\n    /**\n     * Adds the listener to listen to the layer definitionExpression and renderer changes\n     * @category Private\n     */\n    async addLayerListeners() {\n        // removing existing listeners before adding new ones\n        this.removeLayerListeners();\n        this.layerFilterListener = await addLayerFilterListener({\n            layer: this.layer,\n            component: this,\n        });\n        this.layerRendererListener = await addLayerRendererListener({\n            layer: this.layer,\n            component: this,\n        });\n    }\n    /**\n     * Adds the listener to listen to the layer definitionExpression changes\n     * @category Private\n     */\n    async setLayerFilterListener() {\n        this.removeLayerFilterListener();\n        this.layerFilterListener = await addLayerFilterListener({\n            layer: this.layer,\n            component: this,\n        });\n    }\n    /**\n     * Adds a listener to listen to the layer's renderer changes when color match is enabled for a layer data source\n     * @category Private\n     */\n    async setLayerRendererListener() {\n        this.removeLayerRendererListener();\n        this.layerRendererListener = await addLayerRendererListener({\n            layer: this.layer,\n            component: this,\n        });\n    }\n    /**\n     * Adds a listener to listen to the view's extent change\n     * @category Private\n     */\n    async setExtentChangeListener() {\n        // removing existing listeners before adding new ones\n        this.removeExtentChangeListeners();\n        this.extentChangeListeners = await addExtentChangeListener({\n            view: this.view,\n            layer: this.layer,\n            component: this,\n        });\n    }\n    /**\n     * Removes the listeners added to listen to the layer definitionExpression and renderer changes\n     * @category Private\n     */\n    removeLayerListeners() {\n        this.removeLayerFilterListener();\n        this.removeLayerRendererListener();\n    }\n    /**\n     * Removes the layer filter listener when layer definitionExpression changes\n     * @category Private\n     */\n    removeLayerFilterListener() {\n        if (this.layerFilterListener !== undefined) {\n            this.layerFilterListener.remove();\n        }\n    }\n    /**\n     * Removes the layer renderer listener when layer renderer changes\n     * @category Private\n     */\n    removeLayerRendererListener() {\n        if (this.layerRendererListener !== undefined) {\n            this.layerRendererListener.remove();\n        }\n    }\n    /**\n     * Removes the listeners added to listen to the view's extent change\n     * @category Private\n     */\n    removeExtentChangeListeners() {\n        if (this.extentChangeListeners !== undefined) {\n            this.extentChangeListeners.forEach((listener) => listener.remove());\n            this.extentChangeListeners = [];\n        }\n    }\n    /**\n     * If the chart config version is newer than the current one, display a message in a popup.\n     * @category Private\n     */\n    checkForIncompatibleChartVersion() {\n        const chartVersion = this.config?.version;\n        if (this.errorPolicy === Lm.Throw &&\n            jc(chartVersion).versionStatus === WebChartVersionStatus.Newer) {\n            this.notifyHeading = this.errorStrings.incompatibleChartVersion.title;\n            this.notifyMessage = Kr(this.errorStrings.incompatibleChartVersion.message, {\n                chartVersion: chartVersion ?? \"\",\n            });\n            this.notifyOptions = {\n                kind: \"warning\",\n                autoClose: true,\n                active: true,\n            };\n            this.showNotifyPanel = true;\n        }\n    }\n    /**\n     * Updates the config's time zone if needed.\n     * @category Private\n     */\n    updateConfigTimeZone() {\n        if (this.config?.axes?.[0]?.valueFormat.type === WebChartTypes.DateAxisFormat) {\n            this.config.axes[0].valueFormat.intlOptions.timeZone = ta(this.timeZone);\n        }\n    }\n    /**\n     * creates arcgis chart instance\n     * @param {boolean} firstCreation Indicates whether it's the first time the component is created\n     * @category Private\n     */\n    async createChartInstance(firstCreation = true) {\n        // If a chart creation is already running (rare case) we wait for it to be done before continuing\n        if (this.chartCreationProcessing !== undefined) {\n            await this.chartCreationProcessing;\n            this.chartCreationProcessing = undefined;\n        }\n        // Controlling the series type to display a console error if the type is not the expected one\n        // We still proceed to the creation to let the config validator deal with the invalid config\n        await Mc([WebChartTypes.BarSeries], this.config);\n        this.updateConfigTimeZone();\n        this.checkForIncompatibleChartVersion();\n        this.updatedProps.clear();\n        try {\n            if (isValidDataSource(this.config, this.layer)) {\n                const options = gatherComponentOptions({ component: this });\n                await addMissingSplitBySeries(this, options);\n                this.chartCreationProcessing = zY({\n                    chartContainer: this.chartRef,\n                    chartConfig: this.config,\n                    options,\n                    globalOptions: gatherComponentGlobalOptions(this),\n                    t9nStrings: {\n                        errorStrings: this.errorStrings,\n                        commonStrings: this.commonStrings,\n                    },\n                });\n            }\n            this.chart = await this.chartCreationProcessing;\n            this.chartCreationProcessing = undefined;\n            // after creating the chart we add listeners on the feature layer and view\n            // only adding them if it's the first component creation. `createChartInstance()` can be called\n            // when an update failed, and in that case we don't need to add again the listeners given the view\n            // or layer didn't change\n            if (firstCreation) {\n                await this.addLayerListeners();\n                await this.setExtentChangeListener();\n            }\n        }\n        catch (e) {\n            // sending an event if an error occurs.\n            if (e.name === El.QueryFeaturesError) {\n                this.arcgisDataProcessError.emit(e.details);\n            }\n            else {\n                this.arcgisRuntimeError.emit(e.details ?? e);\n            }\n            // displaying the error\n            this.errorAlert(e?.message);\n            // disposing the chart\n            this.chart?.dispose();\n            this.chartCreationProcessing = undefined;\n            this.chart = undefined;\n        }\n    }\n    static get assetsDirs() { return [\"assets\"]; }\n    get el() { return getElement(this); }\n    static get watchers() { return {\n        \"view\": [\"viewChange\"],\n        \"layer\": [\"layerChange\"],\n        \"runtimeDataFilters\": [\"runtimeDataFiltersChange\"],\n        \"returnFeaturesExtent\": [\"returnFeaturesExtentChange\"],\n        \"disableInteractions\": [\"disableInteractionsChange\"],\n        \"rotation\": [\"rotationChange\"],\n        \"legendPosition\": [\"legendPositionChange\"],\n        \"legendVisibility\": [\"legendVisibilityChange\"],\n        \"timeZone\": [\"timeZoneChange\"],\n        \"filterBySelection\": [\"filterBySelectionChanged\"],\n        \"layerFilterChangePolicy\": [\"layerFilterChangePolicyCallBack\"],\n        \"layerRendererChangePolicy\": [\"layerRendererChangePolicyCallBack\"]\n    }; }\n};\nArcGISChartsBarChart.style = ArcgisChartsBarChartStyle0;\n\nexport { ArcGISChartsBarChart as A };\n"],"names":["ArcGISChartsBarChart","constructor","hostRef","registerInstance","this","arcgisRuntimeError","createEvent","arcgisDataProcessError","arcgisDataProcessComplete","arcgisLegendItemVisibilityChange","arcgisUpdateComplete","arcgisBadDataWarningRaise","arcgisSeriesColorChange","arcgisAxesMinMaxChange","arcgisSelectionComplete","arcgisNoRenderPropChange","arcgisSeriesOrder","skipNextUpdate","noRenderProps","dataUpdateNeededProps","updatedProps","Set","config","undefined","rotation","actionMode","cursorRange","legendPosition","legendVisibility","hideEmptySeries","timeZone","view","layer","selectionData","returnSelectionOIDs","returnSelectionIndexes","returnFeaturesExtent","filterBySelection","disableInteractions","queueChartCreation","useAnimatedCharts","hideLicenceWatermark","enableResponsiveFeatures","autoDisposeChart","placeholder","selectionTheme","setTimeBinningInfoWhenNotProvided","chartLimits","tooltipFormatter","dataLabelFormatter","guideTooltipFormatter","xAxisLabelFormatter","yAxisLabelFormatter","messageOptions","errorPolicy","Lm","Throw","disableTogglingLegendItems","hideLoaderAnimation","runtimeDataFilters","usePopupTemplateFieldsInfo","layerFilterChangePolicy","Am","Refresh","layerRendererChangePolicy","Em","ignoreViewExtent","updateSplitBySeries","showNotifyPanel","handleChartOutputDataChange","event","emit","detail","handleLegendItemVisibilityChanged","handleUpdateCompleted","handleBadDataWarningRaise","handleSeriesColorsChange","handleSelection","handleTooManySelectedElements","notifyHeading","errorStrings","tooManySelectedElements","title","notifyMessage","message","notifyOptions","kind","autoClose","duration","active","handleAlertClosed","target","el","handleAxesMinMaxChange","handleSeriesOrder","viewChange","newView","oldView","setExtentChangeListener","refresh","layerChange","addLayerListeners","runtimeDataFiltersChange","add","returnFeaturesExtentChange","disableInteractionsChange","newValue","navigator","userAgent","search","chartRef","classList","HTMLClasses","DisableInteractions","remove","rotationChange","newRotation","xn","legendPositionChange","newLegendPosition","updateLegendPosition","legendVisibilityChange","newLegendVisibility","updateLegendVisibility","timeZoneChange","updateConfigTimeZone","filterBySelectionChanged","resetAxesBounds","layerFilterChangePolicyCallBack","newRefreshOnLayerFilter","Ignore","setLayerFilterListener","removeLayerFilterListener","layerRendererChangePolicyCallBack","newRefreshOnLayerRenderer","setLayerRendererListener","removeLayerRendererListener","notify","heading","options","chart","Promise","resolve","errorAlert","errorMessage","errorHeading","resetZoom","switchSelection","clearSelection","props","updateData","updateExtent","viewExtentUpdated","axes","minimum","maximum","componentDidUpdate","componentShouldUpdate","_len","arguments","length","args","Array","_key","value","propName","isNoRenderProp","includes","shouldUpdate","componentWillLoad","fetchErrorsStrings","commonStrings","fetchCommonStrings","debouncedChartUpdate","promise","async","from","dataUpdateNeeded","some","updatedProp","clear","updateOptions","gatherComponentOptions","component","dataUpdated","addMissingSeries","addMissingSplitBySeries","update","newChartConfig","updateGlobalOptions","gatherComponentGlobalOptions","t9nStrings","maximumNumberOfSimultaneousUpdates","componentDidLoad","createChartInstance","chartCreationProcessing","Mc","WebChartTypes","BarSeries","isValidDataSource","push","e","name","El","ChartDisposed","dispose","innerHTML","QueryFeaturesError","details","actionBarElement","updateActionBarStates","disconnectedCallback","removeLayerListeners","removeExtentChangeListeners","render","notifyPanel","h","ArcgisChartsNotifyPanel","chartStyles","Hide","Show","notifyStyles","NotifyPanel","Host","key","Slot","actionBar","onSlotchange","onActionBarSlotChange","ref","class","layerFilterListener","addLayerFilterListener","layerRendererListener","addLayerRendererListener","extentChangeListeners","addExtentChangeListener","forEach","listener","checkForIncompatibleChartVersion","chartVersion","version","jc","versionStatus","WebChartVersionStatus","Newer","incompatibleChartVersion","Kr","valueFormat","type","DateAxisFormat","intlOptions","ta","firstCreation","zY","chartContainer","chartConfig","globalOptions","assetsDirs","getElement","watchers","style"],"sourceRoot":""}